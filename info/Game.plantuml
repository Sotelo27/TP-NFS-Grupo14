@startuml GameDominio
title Dominio Servidor – Need For Speed
hide FinishStatus
hide MatchState
hide PlayerRaceState
hide RaceState
hide Movimiento
hide Penalizaciones

'ENUMS ----------------------------------------------------------------
enum FinishStatus {
  Finished
  Disqualified
  DNF
}

enum MatchState {
  Waiting
  Racing
  Upgrades
  Finished
}

enum PlayerRaceState {
  NotReady
  Ready
  Racing
  Finished
  Disqualified
}

enum RaceState {
  NotStarted
  Running
  Finished
}

struct Partida {
  game : Game
  gameLoop : GameLoop
}

struct Movimiento {
    bool avanzar = false;
    bool retroceder = false;
    bool girarIzquierda = false;
    bool girarDerecha = false;
};

struct Posicion {
    float x;
    float y;
};

'CLASES ---------------------------------------------------------------

class Server {
  - monitorLobby: MonitorLobby
  - acceptorClientes: Acceptor
  - config: ConfiguracionYML
  + start(config): void
  + tick(): void
}


class MonitorLobby {
  - partidasActivas: Map<GameId, Partida>

  + creaPartida(config): GameId
  + asignarJugador(GameId, jugador): void
  + removerJugador(GameId, jugadorId): void
  + tomarAccionDeJugador(GameId, ClientAction): void
  + iniciarPartida(GameId): void
  + listaDePartidas(): List<GameId>
  + finalizarPartida(GameId): void
}

class GameLoop {
  - game: Game
  - clients: ClientListProtected
  - action_clients: Queue<ClientAction>

  + start(): void 
  + run(): void
  - procesarAcciones(): void
  - iteracionGame(): void
}


class Game {
  - estado: MatchState
  - jugadores: Map<idJugador, Jugador>
  - carreras: List<Carrera>
  - indiceCarreraActual: int
  - tablaAcumulada: ScoreTable
  - maxJugadores: 8
  - registroDePenalizacionesMs: Map<idJugador, uint32>
  '- upgradesDeadlineMs: uint32  (Esto lo dejo por el momento comentado, porque capaz nos servira en un futuro) no entendi:V
  
  + agregarJugador(p: Jugador): void
  + iniciar(): void
  + finalizar(): void
  + avanzarCarrera(): void
  + aplicarAccion(idJugador: uint16, mov: Movimiento): void
  + actualizarSimulacion(dtMs: uint32, nowMs: uint32): void
  ' Congela penalizacionesPendientes de cada Jugador para la carrera que inicia
  ' y limpia el valor en Jugador; se usarán al construir ResultadoCarrera.penalizacionAplicadaMs :3
  + fijarPenalizacionesParaCarrera(): void

  ' Esto va de la mano con lo de upgradesDeadlineMs
  '+ startUpgradesWindow(duracionMs: uint32): void
  '+ isUpgradesOpen(tiempoActualMs: uint32): bool
}

class ScoreTable {
    ' Mapeo de idJugador a ResultadoAcumulado
  - filas: Map<idJugador, ResultadoAcumulado>
  + agregarResultado(resultados: Map<idJugador, ResultadoCarrera>): void
  + getClasificacion(): List<ResultadoAcumulado>
}

class ResultadoCarrera {
  - idJugador: uint16
  - tiempoCarreraMs: uint32
  - penalizacionAplicadaMs: uint32
  - status: FinishStatus
  - cause: string

  + getTiempoEfectivoMs(): uint32
}

class ResultadoAcumulado {
  - acumuladoMs: uint32
  - carrerasCompletadas: uint8
  - ultimaCarreraMs: uint32
  - statusUltima: FinishStatus
  - causeUltima: string

  + agregarResultado(r: ResultadoCarrera): void
  + getAcumuladoMs(): uint32
}

class Jugador {
  - id : uint16
  - nombre : string
  - auto : Auto
  - estado : PlayerRaceState
  - tiempoActualMs : uint32
  - penalizacionPendienteMs : uint32
  - nextCheckpointIdx : uint16
  - cheats : Cheats

  ' finalizar() No aplica penalizacionPendienteMs.
  ' La penalización aplicada en ResultadoCarrera la setea Game usando la congelada al inicio.
  + escogerAuto(auto: Auto) : void
  + aplicarMovimiento(input: Movimiento) : void
  + aplicarMejora(mejora: UpgradeOption) : void
  + agregarPenalizacion(penalizacionMs: uint32) : void
  + limpiarPenalizacionPendiente() : void
  + isFinished() : bool
  + marcarCheckpoint(idxCheckpoint: uint16) : void
  + finalizar(tiempoMs: uint32) : ResultadoCarrera
  + descalificar(causa: string) : ResultadoCarrera
  + reposicionParaCarrera(puntoDeInicio: Spawn) : void
  + getPose() : Posicion  ' {x:float, y:float
}

class Auto {
  - modelo : string
  - velocidadBase : uint16
  - aceleracionBase : uint16
  - masaBase: uint16
  - controlBase : uint16
  - saludMax : uint16
  - saludActual : uint16
  - upgrades : Upgrades

  - posX : float
  - posY : float
  - direccionX : int
  - direccionY : int

  + moverse(mov: Movimiento) : void
  + actualizar(dt: float) : void
  + getPose() : Posicion
}

class Penalizaciones {
  
}

class Recorrido {

}

class Ciudad {
  - nombre : string
}

class Cheats {
  - vidaInfinita: bool
  - autoGanar: bool
  - autoPerder: bool
}


class Carrera {
  - id : uint32
  - estado : RaceState
  - fisicas : PhysicsWorld
  - recorrido : Recorrido
  - reglas : RaceRules
  - jugadores : Map<idJugador, Jugador>
  - progresos : Map<idJugador, ProgresoJugadorCarrera>
  - resultados : Map<idJugador, ResultadoCarrera>
  - npcs : List<NPC>
  - tiempoInicioMs : uint32
  - duracionMaxMs : uint32
  - tiempoCuentaRegresiva : uint32

  + iniciarCarrera(tiempoActualMs: uint32) : void
  + actualizar(dtMs: uint32, tiempoActualMs: uint32) : void
  + aplicarAccion(idJugador: uint16, mov: Movimiento): void
  + registrarPasoPorCheckpoint(idJugador: uint16, idxCheckpoint: uint16) : void
  + registrarChoqueFatal(idJugador: uint16, causa: string) : void
  + verificarLimiteDeTiempo(tiempoActualMs: uint32) : void
  + finalizarCarrera(registroDePenalizacionesMs: Map<idJugador,uint32>) : Map<idJugador, ResultadoCarrera>
  + snapshotPoses() : Map<idJugador, Posicion> 
}


' RELACIONES -----------------------------------------------------------
Server *-- MonitorLobby : compone
Server --> ConfiguracionYML : usa

'MonitorLobby *-- Game : contiene
'MonitorLobby o-- GameLoop : contiene

MonitorLobby *-- Partida : contiene
Partida *-- Game
Partida o-- GameLoop

GameLoop ..> Game : usa

Game o-- Jugador : contiene
Game o-- Carrera : contiene
Game *-- ScoreTable : compone

ScoreTable *-- ResultadoAcumulado : contiene
ScoreTable ..> ResultadoCarrera : usa

Jugador *-- Cheats : compone
Jugador ..> ResultadoCarrera : produce
Jugador --> Auto : tiene
Game ..> ResultadoCarrera : ensambla

' Carrera recolecta resultados de los jugadores y usa componentes del mundo por ahora
Carrera o-- Jugador : contiene
Carrera ..> ResultadoCarrera : recolecta
Carrera --> Recorrido : usa
Carrera --> RaceRules : usa
Carrera *-- PhysicsWorld : contiene

Recorrido --> Ciudad : usa

'NOTAS---------------------------------------------------------------
show Server members
show Server attributes
show Server methods

skinparam noteFontSize 10
note bottom of Game
    Podemos agregarle un ID a 
    cada Game para diferenciarlas.
end note

note left of Game
  Sobre las penalizaciones: se congelan al 
  iniciar la carrera y se aplican en
  ResultadoCarrera.penalizacionAplicadaMs;
  Jugador.finalizar() no las aplica.
end note

note top of MonitorLobby
  Crea y administra múltiples partidas (Game).
  iniciarPartida(GameId) crea GameLoop asociado.
  GameID solo es un identificador int
end note

note bottom of Carrera
  tiempoActualMs: tiempo global en ms (uint32).
  deltaTiempoMs: avance de tiempo entre ticks.
  iniciarCarrera(): fija tiempoInicioMs y deja estado en EnCurso.
  actualizar(): avanza física (Box2D.step) y chequea timeout.
  verificarLimiteDeTiempo(): finaliza si superó duracionMaximaMs (10 min).
  finalizarCarrera(): genera Resultados y aplica penalizaciones de Game.
end note


note bottom of ResultadoCarrera
  getTiempoEfectivoMs() devuelve 
  tiempoCarreraMs + penalizacionAplicadaMs
end note

note bottom of ResultadoAcumulado
  getAcumuladoMs() devuelve la suma de 
  todos los tiempos efectivos de las carreras 
  completadas.
  agregarResultado(r : ResultadoCarrera) 
  Suma un nuevo resultado a los acumulados
end note

note top of ScoreTable
  agregarResultado(resultados):
    for (idJugador, row) in resultados:
        if idJugador no existe -> crear ResultadoAcumulado()
        filas[idJugador].agregarResultado(row)
  
  Actualiza el acumulado total de cada jugador
  segun los ResultadoCarrera de la carrera.
end note

@enduml